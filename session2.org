#+title: Session2
#+author: Atri Hegde
#+startup: showall

* Preface

Now that we know the basics our stack, let's start GETting and POSTing data from our database.

* Table of Contents :TOC:
- [[#preface][Preface]]
- [[#page-metadata][Page metadata]]
  - [[#default-metadata][Default metadata]]
- [[#creating-a-home-page][Creating a home page]]
  - [[#icons][Icons]]
  - [[#basic-styling][Basic styling.]]
- [[#more-on-components][More on components.]]
- [[#feed-page][Feed page]]
  - [[#creating-the-page][Creating the page]]
  - [[#dummy-post][Dummy post]]
  - [[#shadcn-and-zod][shadcn and zod]]
  - [[#createpost-component][CreatePost Component.]]
- [[#solo-activity][Solo activity]]

* Page metadata

We want to be able to set custom page title and descriptions for all of our pages. For this first we set it in the root layout.

This means, if we don't specify a change, all our pages have that 'default' metadata.

#+begin_quote
Metadata is the hidden page data that the browser and bots on the internet use to get information on the website.
- Page title: displayed on the tab
- Page description: displayed on google search results, and in small text in url previews.
- keywords: Just "tags" used for SEO.
#+end_quote

** Default metadata

We can see that Next.js has already given us some default metadata in =app/layout.tsx=.

#+begin_src typescript
export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
};
#+end_src

You can put this snippet on any page, and it will have those fields updated for that page.

Lets modify this by adding a logo/image and some keywords.

First copy over the logo from [[./public/logo.png][the public directory]] and put it in your project's public directory.

#+begin_quote
Here we also add =metadataBase= property. This is because we are specifying which domain we are getting the images from.
#+end_quote

#+begin_src typescript
export const metadata: Metadata = {
  metadataBase: new URL('https://localhost:3000'),
  title: 'Instr',
  description: 'Twitter like application where you share posts.',
  keywords: 'Instr, Twitter, Instagram, Reddit',
  icons: '/logo.png',
  openGraph: {
    title: 'Instr',
    description: 'Twitter like application where you share posts.',
    images: '/logo.png',
  },
};
#+end_src

Now if you refresh the page, you should see the new icon on your tab from the =icons= property and when you share this url, the same logo next to it.

This piece of typescript code produced the following HTML.

#+begin_src html
<title>Instr</title>
<meta name="description" content="Twitter like application where you share posts."/>
<meta name="keywords" content="Instr, Twitter, Instagram, Reddit"/><meta property="og:title" content="Instr"/>
<meta property="og:description" content="Twitter like application where you share posts."/>
<meta property="og:image" content="http://localhost:3000/logo.png"/>
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:title" content="Instr"/>
<meta name="twitter:description" content="Twitter like application where you share posts."/>
<meta name="twitter:image" content="http://localhost:3000/logo.png"/>
<link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/>
#+end_src

* Creating a home page

Let's get some of the prebuilt Next.js css.
Go delete everything except the tailwind imports in =globals.css= so it looks like this:

#+begin_src css
@tailwind base;
@tailwind components;
@tailwind utilities;
#+end_src

** Icons

We want to use some icons later on, so lets install an icons package. I like tabler-icons.

#+begin_src shell
yarn add @tabler/icons-react
#+end_src

You can find the list of icons on their [[https://tabler-icons.io][website]].

** Basic styling.

1. Please go to =layout.tsx= and have a look at the =className='s on the html, body and main tags.

#+begin_quote
Some basic styling such as page background, text colour, and some nice padding on our =<main>= to give make it look better (also slightly responsive?!).
#+end_quote

2. Place your =NavMenu= component above the main tag rather than inside of it.

#+begin_quote
Our navbar resizing and styling are different to the contents of the page. So we need to not have it inside of the main tag.
#+end_quote

3. Update your =Navbar= component with the updated code.

#+begin_quote
Make it an actual navbar. By default almost everything in tailwind is unstyled like links, buttons and headings.

Let's give our links underlines and buttons backgrounds from now on!
#+end_quote

4. Also update your =page.tsx= with the provided code.

#+begin_quote
Basic landing page. We also have some conditional rendering at the bottom.
#+end_quote

You now have a basic home screen.

* More on components.

Let's change our login button on the navbar now. I want to accomplish two things.
1. It should go back to the page the user clicked the button from.
2. Directly take us to the google account selector without the visiting =/api/auth/signin=.

Let's first abstract this login button to its own component.

I am creating mine at =@/components/auth/GoogleSignInButton.tsx=.

Lets create a simple react arrow function component which just returns the we already made.

I am also going to add Google logo from tabler-icons.

For the =onClick()= action of this button we can specify that we want to use the google provider.

Here I will also provide a =callbackUrl= which will inform =signIn()= from next-auth where to redirect to after a user has loggedIn. This is just a little bit of a knowledge bomb.

I want this button to take in an argument for this redirect, but can optionally be nil. e.i. it will redirect to whatever page the button was pressed from.

#+begin_src typescript
import { IconBrandGoogle } from '@tabler/icons-react';
import { signIn } from 'next-auth/react';
import { useSearchParams } from 'next/navigation';

interface buttonProps {
  callbackUrl?: string;
}

const GoogleSignInButton = (props: buttonProps) => {
  const url = props.callbackUrl ?? useSearchParams().get('callbackUrl') ?? '';
  return (
    <button
      className='flex items-center rounded-md bg-slate-900 p-2 transition duration-300 hover:bg-slate-950'
      onClick={() => signIn('google', { callbackUrl: url })}
    >
      <p className='pr-2'>Login</p> <IconBrandGoogle height={25} width={25} />
    </button>
  );
};

export default GoogleSignInButton;
#+end_src

* Feed page

** Creating the page

We want tit to be a guarded page.

First lets create the directory for this route =app/feed=.

Then let's create the file =page.tsx= inside this folder.

You should now be used to creating new components.

We are going to be using server components where possible.

#+begin_src javascript
const Feed = () => {
  return (
    <div>
      <p>Feed page</p>
    </div>
  );
};

export default Feed;
#+end_src

*** Guard the route.

Lets continue by using an if statement.

#+begin_src typescript
import { getServerSession } from 'next-auth';
import { authOptions } from '../api/auth/[...nextauth]/route';

const Feed = async () => {
  const session = await getServerSession(authOptions);
  if (session) {
    return (
      <div>
        <p>Feed page</p>
      </div>
    );
  }
};

export default Feed;
#+end_src

For now lets just render one static postcard.

*** Creating the Post model.

Let go add a new model in our schema called post.

#+begin_src prisma
model Post {
  id        String  @id @default(cuid())
  userId    String
  title     String
  published Boolean @default(true)
  views     Int     @default(0)
  likes     Int     @default(0)

  user User @relation(fields: [userId], references: [id])
  // If we want to delete all the users posts if they delete their account.
  // user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}
#+end_src

Now we run =npx prisma migrate dev --name added-posts=.

#+begin_quote
Prisma is something that is running on the server side. This means that we cannot use prismaClient on the browser.
So we will be creating API's instead. This is one of the caveats of having a client side Session wrapper.
#+end_quote


** Dummy post

*** Server side

Checking auth state on the server side is a bit cumbersome but we can use our =prisma= object so we don't have to create an api for it.

Here we have the =await= keyword in multiple places. Next.js 13 allows us to create a =loading.tsx= with default export of =Loading= and it will automatically display this loading screen until the data is fetched.

#+begin_src typescript
import { getServerSession } from 'next-auth';
import { authOptions } from '../api/auth/[...nextauth]/route';
import { redirect } from 'next/navigation';
import prisma from '@/lib/prisma';
import PostCard from '@/components/posts/PostCard';

const Feed = async () => {
  const session = await getServerSession(authOptions);
  let posts = await prisma.post.findMany();

  if (session) {
    return (
      <div>
        <div className='mx-auto w-1/2'>
          {posts.map((post, index) => {
            return (
              <div className='my-2'>
                <PostCard
                  title={post.title}
                  description={post.description}
                  id={post.userId}
                  key={index}
                />
              </div>
            );
          })}
        </div>
      </div>
    );
  } else {
    redirect('/');
  }
};

export default Feed;
#+end_src

Try both of these loading screens out and keep what you like!

**** Loading 1

#+begin_src typescript
const Loading = () => {
  return (
    <div
      className='fixed left-0 top-0 flex h-screen w-screen items-center
  justify-center'
    >
      <div
        className='h-16 w-16 animate-spin rounded-full border-b-2 border-t-2
  border-gray-100'
      ></div>
    </div>
  );
};

export default Loading;
#+end_src

**** Loading 2

#+begin_src typescript
const Skeleton = () => {
  return (
    <div className='mx-auto my-2 w-1/2 animate-pulse rounded-md bg-slate-800 p-2'>
      <h1 className='mx-auto my-1 h-6 w-48 rounded-md bg-slate-700 text-center text-xl font-bold'></h1>
      <div className='mx-auto mt-2 h-4 w-3/4 rounded-md bg-slate-700 p-2'></div>
      <div className='mx-auto mt-2 h-4 w-3/4 rounded-md bg-slate-700 p-2'></div>
      <div className='mx-auto mt-2 h-4 w-3/4 rounded-md bg-slate-700 p-2'></div>
      <div className='mx-auto mt-2 h-4 w-3/4 rounded-md bg-slate-700 p-2'></div>
      <p className='mx-auto my-1 my-1 h-4 w-1/5 animate-pulse rounded-md bg-slate-700 text-center italic'></p>
    </div>
  );
};
const Loading = () => {
  return (
    <>
      <Skeleton />
      <Skeleton />
      <Skeleton />
    </>
  );
};

export default Loading;
#+end_src

*** Client side

For now let us just create a dummy post using prisma studio (=npx prisma studio=).

Let's also make an api endpoint to get these posts (=/api/posts= but file should be =app/api/posts/route.ts=).

#+begin_src typescript
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { NextResponse } from 'next/server';
import { authOptions } from '../auth/[...nextauth]/route';

export async function GET() {
  // No authorisation required. But we can change that
  const posts = await prisma.post.findMany();
  setTimeout(() => {}, 2000);
  return NextResponse.json(posts);
}
#+end_src

We can test this using multiple ways. My preferred method is using =httpie= in the command line for small simple requests and for the more complex ones (providing a body for POST method or authorisation headers) I use =Insomnium=.

- [[https://github.com/ArchGPT/insomnium/releases/tag/core%400.2.1-b][Windows download]] for Insomnium.
- =insomnium-bin= available from the AUR.

#+begin_quote
Note: Not Insomnia but Insomnium.
#+end_quote

**** curl

#+begin_src shell
curl http://localhost:3000/api/posts
#+end_src

**** httpie

#+begin_src shell
# Install it - Arch Linux
sudo pacman -S httpie
# using it
http GET http://localhost:3000/api/posts
#+end_src

**** Insomnium :ATTACH:

Just type the url =http://localhost:3000/api/posts= and select the =GET= method. All you have to do is click send and you should get a response.

[[./insomnium.png]]

Now that we've verified that our API works, let's get to making the client feed page. Make it accessible to this url =/client=. I've also added a =loading.tsx= just like earlier to give a nice animation whilst the posts load.

#+begin_src typescript
'use client';

import { Suspense, useEffect, useState } from 'react';
import Loading from './loading';
import { redirect } from 'next/navigation';
import type { Post } from '@prisma/client';
import { useSession } from 'next-auth/react';

const Feed = () => {
  const { data: session } = useSession();
  const [posts, setPosts] = useState<Post[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch('/api/posts')
      .then((res) => res.json())
      .then((data) => {
        setPosts(data as Post[]);
        setLoading(false);
      });
  }, []);

  if (session) {
    if (loading) {
      return <Loading />;
    }
    return (
      <div>
        <Suspense fallback={<Loading />}>
          <div className='mx-auto w-1/2'>
            {posts.map((post, index) => {
              return (
                <div className='rounded-md bg-slate-800 p-2 my-2' key={index}>
                  <div className='font-3xl'>{post.title}</div>
                  <div>{post.description}</div>
                </div>
              );
            })}
            <CreatePost />
          </div>
        </Suspense>
      </div>
    );
  } else {
    redirect('/');
  }
};

export default Feed;
#+end_src

** shadcn and zod
*** shadcn

This is a UI library. We did not have a need for this, but as we introduce more and more components, this UI library that is very easily and extensively customisable will be very useful.

- [[https://ui.shadcn.com/docs/installation/next][Docs]].

Lets install it with:

#+begin_src shell
npx shadcn-ui@latest init
#+end_src

Lets also add the form and button components

#+begin_src shell
npx shadcn-ui@latest add button
npx shadcn-ui@latest add form
#+end_src

shadcn doesn't actually install any packages. Instead it creates files inside of =components/ui= that you can use straight away. Or you can modify them to your liking.

*** Zod

Zod is a validation library. It helps us validate the input and provide error messages.

Let's install it.

#+begin_src shell
yarn add zod
#+end_src

**** Using zod

Since we will want to validate the same types of objects in multiple locations, we define something called as a zod schema, which contains all the properties and their constraints.

Let's create the folder =lib/validations= for all these schema's. Let's also create a file in this folder =post.ts= which contains the schema for posts.

#+begin_src typescript
import { z } from 'zod';

export const postSchema = z.object({
  title: z.string(),
  description: z.string().max(250),
});
#+end_src

** CreatePost Component.

Now let's create a component for creating a post. There are a lot of patterns we can follow for this.

This also shows that you can "embed" a =client= component into a =server= component.

#+begin_quote
Server components cannot have any "interactivity" as it will have no clue about the user's state. We can still use standard HTML form actions, but we are NOT using that.

Client components can have interactivity. We will be using =useState= and =useEffect= hooks.
We will also be using a js/ts library called =zod= to validate the form data before performing any action and give validation errors.
#+end_quote

* Solo activity

Create a login page to replace the default one provided by next-auth.
